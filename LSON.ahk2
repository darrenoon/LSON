; self references (tree) syntax: 
;   / is root object
;   sub objects referenced by index
;   if reference ends with "k" it is the key-object at that index
;   each nest level adds another "/"
;
; e.g.
; /       refers to root itself
; /2      refers to the root's second index value
; /4k     refers to the root's fourth index *key* (object-key)
; /1/5k/3 refers to: root first index value -> fifth index key -> third index value

LSON( obj, seps := "", lobj := "", tpos := "" ) {
    array := True
    
    tpos .= "/"
    if !IsObject(lobj)
        lobj := Object("r" &obj, tpos) ; this root object is static through all recursion
    sep := seps._maxindex() ? seps.remove(1) : ", "
    
    for k,v in obj
    {
        retObj .= sep
        
        if IsObject(k)
            if (lobj.HasKey("r" &k))
                retObj .= lobj["r" &k]
            else
            {
                lobj.insert("r" &k, tpos A_Index "k")
                if IsFunc(k)
                    retObj .= k.Name "()"
                else
                    retObj .= LSON(k, seps.clone(), lobj, tpos A_Index "k")
            }
        else
            retObj .= (k ~= "^[a-zA-Z0-9#_@$]+$" ? k : "`"" RegExReplace(k,"`"","$0$0") "`"")
        retObj .= ": "
        
        if IsObject(v)
            if (lobj.HasKey("r" &v))
                v := lobj["r" &v]
            else
            {
                lobj.insert("r" &v, tpos A_Index)
                if IsFunc(v)
                    v := v.Name "()"
                else
                    v := LSON(v, seps.clone(), lobj, tpos A_Index)
            }
        else
            if (v ~= "[^\x01-\x7F]") ;contains non-ascii characters
                v := v ; this should hex-ify v based on GetCapacity()
            else
                v := v+0 != "" ? v : "`"" RegExReplace(v,"`"","$0$0") "`""
        
        retObj .= v
        
        if (array := array && (k + 0 != "") && (k == A_Index) && (k == Abs(k)) && (k == Floor(k)))
            retArr .= sep v
    }
    if array
        ret := "[" SubStr(retArr, 1 + StrLen(sep)) "]"
    else
        ret := "{" SubStr(retObj, 1 + StrLen(sep)) "}"
    return ret
}

LSON_Normalize(text) 
{
    
}

myobj := ["someobject", 1, 7]
dispobj := { 123: [4, 5, 6], test: "this is `"text`"", "testing foobar": "abc def", reference: myobj }
dispobj.insert(myobj, "object key value")
msgbox % LSON( dispobj )

parent := { "_me": "parent" }
child  := { "_me": "child", parent: parent }
parent["child"] := child
msgbox % LSON(parent)
msgbox % LSON(child)

myobj := { help: Func("myfunc") }
myobj.self := myobj
msgbox % LSON(myobj)
myfunc() {
    msgbox help me!
}
